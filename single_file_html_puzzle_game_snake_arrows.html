<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Arrow Sweep — Mini Puzzle</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0e1630;
      --text:#e9ecff;
      --muted:#aab2df;
      --accent:#7aa2ff;
      --good:#4ade80;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 35px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 20% 10%, #17204a 0%, rgba(23,32,74,0) 50%),
                  radial-gradient(900px 700px at 80% 40%, #1b2a5a 0%, rgba(27,42,90,0) 55%),
                  var(--bg);
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }

    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .top{
      display:flex;
      gap: 12px;
      align-items: stretch;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .title{
      display:flex;
      flex-direction: column;
      gap: 6px;
      min-width: 280px;
      flex: 1;
    }

    .title h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .2px;
      line-height: 1.2;
    }
    .title p{
      margin:0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:flex-end;
      flex: 1;
      min-width: 280px;
    }

    .pill{
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 10px 12px;
      display:flex;
      gap: 8px;
      align-items:center;
      min-height: 42px;
    }
    .pill .k{
      color: var(--muted);
      font-size: 12px;
    }
    .pill .v{
      font-weight: 700;
      font-size: 13px;
    }

    button{
      appearance:none;
      border:none;
      background: rgba(122,162,255,.18);
      color: var(--text);
      border: 1px solid rgba(122,162,255,.5);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 650;
      transition: transform .08s ease, background .15s ease;
      min-height: 42px;
    }
    button:hover{ background: rgba(122,162,255,.26); }
    button:active{ transform: translateY(1px) scale(.99); }

    button:disabled{
      opacity: 0.55;
      cursor: not-allowed;
    }

    .game{
      position: relative;
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .stage{
      position: relative;
      background: linear-gradient(180deg, rgba(0,0,0,.28), rgba(0,0,0,.18));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
    }

    canvas{
      display:block;
      width:100%;
      height:auto;
      aspect-ratio: 16 / 9;
    }

    .toast{
      position:absolute;
      inset: 14px auto auto 14px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(8,12,26,.62);
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      color: var(--text);
      max-width: min(520px, calc(100% - 28px));
      pointer-events:none;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show{ opacity: 1; transform: translateY(0); }

    .toast strong{ color: var(--accent); }

    .footer{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .footer .hint{
      color: var(--muted);
      font-size: 12.5px;
      line-height: 1.35;
      max-width: 540px;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 7px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      color: var(--text);
    }

    @media (max-width: 520px){
      .hud{ justify-content: stretch; }
      .pill{ flex: 1; }
      button{ flex: 1; }
    }

    .settings{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      min-width: 360px;
    }
    .settings-row{
      display:flex;
      gap:10px;
      align-items:flex-end;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .settings label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      padding: 8px 10px;
      border-radius: 12px;
      min-height: 42px;
    }
    .settings input{
      width: 92px;
      padding: 7px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline: none;
      font-weight: 650;
    }
    .settings input:focus{
      border-color: rgba(122,162,255,.55);
      box-shadow: 0 0 0 3px rgba(122,162,255,.18);
    }
    .settings-note{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      min-height: 16px;
    }

    @media (max-width: 900px){
      .footer{ align-items: stretch; }
      .footer .hint{ max-width: unset; }
      .settings{ align-items:stretch; min-width: unset; width:100%; }
      .settings-row{ justify-content: stretch; }
      .settings label, .settings input, #applyBtn{ flex: 1; width: auto; }
    }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="card title">
        <h1>Snake Arrow Sweep</h1>
        <p>
          Click an arrow-snake to send it sliding off-screen. But beware: arrows block each other—
          an arrow can only leave if its head lane to the edge is clear.
          Clear the board so <strong>no arrow remains</strong>.
        </p>
      </div>
      <div class="card hud">
        <div class="pill" title="Remaining arrows">
          <div class="k">Remaining</div>
          <div class="v" id="remaining">–</div>
        </div>
        <div class="pill" title="Moves made">
          <div class="k">Moves</div>
          <div class="v" id="moves">0</div>
        </div>
        <button id="newBtn" title="Generate a new random puzzle">New Puzzle</button>
      </div>
    </div>

    <div class="game">
      <div class="stage">
        <canvas id="c" width="960" height="540" aria-label="Puzzle board"></canvas>
        <div class="toast" id="toast"></div>
      </div>
      <div class="card footer">
        <div class="hint">
          Rules: click a snake to send it out in its facing direction. A snake can exit only if there is no other snake
          in the strip in front of its <strong>head</strong>. The tail will unwind and follow.
          <span class="kbd">R</span> = new puzzle, <span class="kbd">U</span> = undo.
        </div>
        <div class="settings" aria-label="Puzzle settings">
          <div class="settings-row">
            <label>Snakes
              <input id="optCount" type="number" min="1" max="40" step="1" value="14" />
            </label>
            <label>Min length
              <input id="optMinLen" type="number" min="2" max="20" step="1" value="2" />
            </label>
            <label>Max length
              <input id="optMaxLen" type="number" min="2" max="30" step="1" value="20" />
            </label>
            <button id="applyBtn" title="Apply settings and generate a new solvable puzzle">Apply</button>
          </div>
          <div class="settings-note" id="settingsNote"></div>
        </div>
        <div style="display:flex;gap:10px;align-items:center;">
          <button id="undoBtn" title="Undo last move">Undo</button>
        </div>
      </div>
    </div>
  </div>

  <script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const remainingEl = document.getElementById('remaining');
  const movesEl = document.getElementById('moves');
  const newBtn = document.getElementById('newBtn');
  const applyBtn = document.getElementById('applyBtn');
  const optCount = document.getElementById('optCount');
  const optMinLen = document.getElementById('optMinLen');
  const optMaxLen = document.getElementById('optMaxLen');
  const settingsNote = document.getElementById('settingsNote');
  const undoBtn = document.getElementById('undoBtn');
  const toast = document.getElementById('toast');

  // Canvas world size (fixed logical coords)
  const W = canvas.width;
  const H = canvas.height;

  // Grid (snakes are generated on cell centers, but unwind in pixels when leaving)
  const CELL = 30; // px
  const COLS = Math.floor(W / CELL);
  const ROWS = Math.floor(H / CELL);

  // --- Utils (must be defined before any usage) ---
  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));

  // --- User options (persisted) ---
  const DEFAULTS = {
    count: 14,
    minLen: 2,
    maxLen: 20
  };

  function loadOptions() {
    try {
      const raw = localStorage.getItem('snakeArrowOptions');
      if (!raw) return { ...DEFAULTS };
      const o = JSON.parse(raw);
      return {
        count: Number.isFinite(+o.count) ? +o.count : DEFAULTS.count,
        minLen: Number.isFinite(+o.minLen) ? +o.minLen : DEFAULTS.minLen,
        maxLen: Number.isFinite(+o.maxLen) ? +o.maxLen : DEFAULTS.maxLen
      };
    } catch {
      return { ...DEFAULTS };
    }
  }

  function saveOptions(o) {
    localStorage.setItem('snakeArrowOptions', JSON.stringify(o));
  }

  let OPTIONS = loadOptions();

  function syncOptionsUI() {
    optCount.value = String(OPTIONS.count);
    optMinLen.value = String(OPTIONS.minLen);
    optMaxLen.value = String(OPTIONS.maxLen);
  }

  function validateAndClampOptions(fromUI = true) {
    let count = fromUI ? parseInt(optCount.value, 10) : OPTIONS.count;
    let minLen = fromUI ? parseInt(optMinLen.value, 10) : OPTIONS.minLen;
    let maxLen = fromUI ? parseInt(optMaxLen.value, 10) : OPTIONS.maxLen;

    if (!Number.isFinite(count)) count = DEFAULTS.count;
    if (!Number.isFinite(minLen)) minLen = DEFAULTS.minLen;
    if (!Number.isFinite(maxLen)) maxLen = DEFAULTS.maxLen;

    // Hard constraints
    count = clamp(count, 1, 40); // solver bitmask limit
    minLen = clamp(minLen, 2, 20);
    maxLen = clamp(maxLen, 2, 30);
    if (minLen > maxLen) [minLen, maxLen] = [maxLen, minLen];

    // Soft density hint (non-blocking)
    const maxCells = COLS * ROWS;
    const minNeeded = count * minLen;
    let note = '';
    if (minNeeded > maxCells * 0.80) {
      note = `That’s very dense for this board. Try fewer snakes or shorter lengths.`;
    }
    settingsNote.textContent = note;

    OPTIONS = { count, minLen, maxLen };
    syncOptionsUI();
    saveOptions(OPTIONS);
    return OPTIONS;
  }

  // Visual thickness
  const BASE_THICK = 16; // px

  // How far outside the canvas snakes slide before being removed
  const EXIT_PADDING = 14;

  // Generation / solver
  const MAX_GEN_ATTEMPTS = 700;

  // Directions
  const DIRS = [
    { key: 'R', dx: 1, dy: 0, ang: 0, name: 'right' },
    { key: 'L', dx: -1, dy: 0, ang: Math.PI, name: 'left' },
    { key: 'D', dx: 0, dy: 1, ang: Math.PI / 2, name: 'down' },
    { key: 'U', dx: 0, dy: -1, ang: -Math.PI / 2, name: 'up' }
  ];

  // --- Self-tests (basic sanity checks; prints to console) ---
  function runSelfTests() {
    console.assert(clamp(5, 1, 10) === 5, 'clamp within range');
    console.assert(clamp(-1, 0, 10) === 0, 'clamp low');
    console.assert(clamp(99, 0, 10) === 10, 'clamp high');

    // validateAndClampOptions should never produce invalid ranges
    const saved = { ...OPTIONS };
    OPTIONS = { count: 999, minLen: 20, maxLen: 2 }; // intentionally wrong
    syncOptionsUI();
    validateAndClampOptions(false);
    console.assert(OPTIONS.count >= 1 && OPTIONS.count <= 40, 'options count clamped');
    console.assert(OPTIONS.minLen >= 2 && OPTIONS.minLen <= 20, 'options minLen clamped');
    console.assert(OPTIONS.maxLen >= 2 && OPTIONS.maxLen <= 30, 'options maxLen clamped');
    console.assert(OPTIONS.minLen <= OPTIONS.maxLen, 'options min<=max');

    // restore
    OPTIONS = saved;
    syncOptionsUI();
    validateAndClampOptions(false);
  }

  // --- State ---
  let snakes = []; // active snakes
  let animating = false;
  let moves = 0;
  let history = [];
  let hoverId = null;

  // Toast
  let toastTimer = null;
  function showToast(html, ms = 1500) {
    toast.innerHTML = html;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), ms);
  }

  // --- Grid / pixel helpers ---
  function cellCenter(c) {
    return { x: (c.x + 0.5) * CELL, y: (c.y + 0.5) * CELL };
  }

  function seededColor(seed) {
    const hue = (seed * 57) % 360;
    return {
      fill: `hsla(${hue}, 85%, 64%, 0.95)`,
      fill2: `hsla(${(hue + 18) % 360}, 90%, 58%, 0.95)`,
      stroke: `hsla(${hue}, 90%, 22%, 0.55)`
    };
  }

  function uuid() {
    return crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2);
  }

  // --- History (undo) ---
  function deepCopyState(list) {
    // Only store static data needed to reconstruct
    return list.map((s) => ({
      id: s.id,
      dir: s.dir,
      lenCells: s.lenCells,
      thick: s.thick,
      colorSeed: s.colorSeed,
      cells: s.cells.map((c) => ({ x: c.x, y: c.y })),
      isLeaving: false,
      seg: null,
      vx: 0,
      vy: 0
    }));
  }

  function pushHistory() {
    history.push({ snakes: deepCopyState(snakes), moves });
    if (history.length > 90) history.shift();
    undoBtn.disabled = history.length === 0;
  }

  function popHistory() {
    const snap = history.pop();
    if (!snap) return;
    snakes = deepCopyState(snap.snakes);
    moves = snap.moves;
    animating = false;
    hoverId = null;
    undoBtn.disabled = history.length === 0;
    updateHUD();
    draw();
  }

  // --- Geometry: dynamic polyline (segments) ---
  function ensureSegments(s) {
    if (s.seg && s.seg.length) return;
    // seg[0] = head point (center), then body points
    s.seg = s.cells.map(cellCenter).map((p) => ({ x: p.x, y: p.y }));
  }

  function polylinePoints(s) {
    // Use dynamic segments if leaving, otherwise derive from cells
    let pts;
    if (s.isLeaving) {
      ensureSegments(s);
      pts = s.seg;
    } else {
      pts = s.cells.map(cellCenter);
    }

    // Add slight head forward extension and tail extension for nicer caps
    const d = DIRS[s.dir];
    const out = pts.map((p) => ({ x: p.x, y: p.y }));

    const head = out[0];
    const headExt = Math.min(CELL * 0.40, s.thick * 1.0);
    out.unshift({ x: head.x + d.dx * headExt, y: head.y + d.dy * headExt });

    const tail = out[out.length - 1];
    const prev = out[out.length - 2] || tail;
    const tx = tail.x - prev.x;
    const ty = tail.y - prev.y;
    const tlen = Math.hypot(tx, ty) || 1;
    const tailExt = Math.min(CELL * 0.35, s.thick * 0.9);
    out.push({ x: tail.x + (tx / tlen) * tailExt, y: tail.y + (ty / tlen) * tailExt });

    return out;
  }

  function buildStrokePath(s) {
    const pts = polylinePoints(s);
    const p = new Path2D();
    p.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) p.lineTo(pts[i].x, pts[i].y);
    return p;
  }

  function headCenterPx(s) {
    if (s.isLeaving) {
      ensureSegments(s);
      return { x: s.seg[0].x, y: s.seg[0].y };
    }
    return cellCenter(s.cells[0]);
  }

  function buildHeadTrianglePath(s) {
    const d = DIRS[s.dir];
    const head = headCenterPx(s);
    const hx = head.x;
    const hy = head.y;

    const headLen = clamp(s.thick * 1.35, 18, 30);
    const headW = clamp(s.thick * 0.95, 14, 26);

    const tipX = hx + d.dx * headLen;
    const tipY = hy + d.dy * headLen;

    const baseCX = hx - d.dx * (s.thick * 0.15);
    const baseCY = hy - d.dy * (s.thick * 0.15);

    const px = -d.dy;
    const py = d.dx;

    const leftX = baseCX + px * (headW * 0.5);
    const leftY = baseCY + py * (headW * 0.5);
    const rightX = baseCX - px * (headW * 0.5);
    const rightY = baseCY - py * (headW * 0.5);

    const p = new Path2D();
    p.moveTo(tipX, tipY);
    p.lineTo(leftX, leftY);
    p.lineTo(rightX, rightY);
    p.closePath();
    return p;
  }

  function getAABB(s) {
    const pts = polylinePoints(s);
    let x1 = Infinity,
      y1 = Infinity,
      x2 = -Infinity,
      y2 = -Infinity;
    for (const p of pts) {
      x1 = Math.min(x1, p.x);
      y1 = Math.min(y1, p.y);
      x2 = Math.max(x2, p.x);
      y2 = Math.max(y2, p.y);
    }
    const pad = s.thick * 0.85;
    return { x1: x1 - pad, y1: y1 - pad, x2: x2 + pad, y2: y2 + pad };
  }

  function aabbOverlap(A, B) {
    return !(A.x2 < B.x1 || A.x1 > B.x2 || A.y2 < B.y1 || A.y1 > B.y2);
  }

  function pointInAABB(x, y, bb) {
    return x >= bb.x1 && x <= bb.x2 && y >= bb.y1 && y <= bb.y2;
  }

  function hitTestSnake(px, py, s) {
    const bb = getAABB(s);
    if (!pointInAABB(px, py, bb)) return false;

    const headTri = buildHeadTrianglePath(s);
    if (ctx.isPointInPath(headTri, px, py)) return true;

    const strokePath = buildStrokePath(s);
    ctx.save();
    ctx.lineWidth = s.thick;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    const ok = ctx.isPointInStroke(strokePath, px, py);
    ctx.restore();
    return ok;
  }

  // --- Blocking / exit rules ---
  // IMPORTANT: Movement is head-led (snake unwinds), so the only check is whether the HEAD'S lane to the edge is clear.
  function headLaneRect(s) {
    const d = DIRS[s.dir];
    const head = headCenterPx(s);
    const w = s.thick * 1.35;
    const half = w / 2;

    if (d.dx === 1) return { x1: head.x + s.thick * 0.6, y1: head.y - half, x2: W + 999, y2: head.y + half };
    if (d.dx === -1) return { x1: -999, y1: head.y - half, x2: head.x - s.thick * 0.6, y2: head.y + half };
    if (d.dy === 1) return { x1: head.x - half, y1: head.y + s.thick * 0.6, x2: head.x + half, y2: H + 999 };
    return { x1: head.x - half, y1: -999, x2: head.x + half, y2: head.y - s.thick * 0.6 };
  }

  function canExit(s, list = snakes) {
    const lane = headLaneRect(s);
    for (const o of list) {
      if (o.id === s.id) continue;
      if (aabbOverlap(lane, getAABB(o))) return false;
    }
    return true;
  }

  // --- Rendering ---
  function drawBackground() {
    ctx.clearRect(0, 0, W, H);

    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, 'rgba(255,255,255,0.06)');
    g.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // Grid
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= W; x += CELL) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, H);
      ctx.stroke();
    }
    for (let y = 0; y <= H; y += CELL) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(W, y + 0.5);
      ctx.stroke();
    }
    ctx.restore();

    // Vignette
    const v = ctx.createRadialGradient(
      W * 0.5,
      H * 0.5,
      Math.min(W, H) * 0.15,
      W * 0.5,
      H * 0.5,
      Math.max(W, H) * 0.7
    );
    v.addColorStop(0, 'rgba(0,0,0,0)');
    v.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = v;
    ctx.fillRect(0, 0, W, H);

    // Border glow
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(122,162,255,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, W - 2, H - 2);
    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawOneSnake(s, highlight = false) {
    const { fill, fill2, stroke } = seededColor(s.colorSeed);
    const body = buildStrokePath(s);

    // Shadow
    ctx.save();
    ctx.translate(3, 4);
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = 'rgba(0,0,0,0.95)';
    ctx.lineWidth = s.thick + 3;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke(body);
    ctx.restore();

    // Gradient
    const bb = getAABB(s);
    const grad = ctx.createLinearGradient(bb.x1, bb.y1, bb.x2, bb.y2);
    grad.addColorStop(0, fill2);
    grad.addColorStop(0.55, fill);
    grad.addColorStop(1, fill2);

    // Body
    ctx.save();
    ctx.strokeStyle = grad;
    ctx.lineWidth = s.thick;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke(body);

    // Outline
    ctx.strokeStyle = highlight ? 'rgba(255,255,255,0.85)' : stroke;
    ctx.lineWidth = highlight ? 4 : 2;
    ctx.stroke(body);
    ctx.restore();

    // Head
    const headTri = buildHeadTrianglePath(s);
    ctx.save();
    ctx.fillStyle = grad;
    ctx.strokeStyle = highlight ? 'rgba(255,255,255,0.85)' : stroke;
    ctx.lineWidth = highlight ? 3 : 2;
    ctx.fill(headTri);
    ctx.stroke(headTri);
    ctx.restore();

    // Eyes
    const d = DIRS[s.dir];
    const head = headCenterPx(s);
    const px = -d.dy;
    const py = d.dx;

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    const eyeDist = Math.max(4, s.thick * 0.18);
    const eyeBack = Math.max(6, s.thick * 0.32);
    const ex = head.x - d.dx * eyeBack;
    const ey = head.y - d.dy * eyeBack;
    ctx.beginPath();
    ctx.arc(ex + px * eyeDist, ey + py * eyeDist, 2.4, 0, Math.PI * 2);
    ctx.arc(ex - px * eyeDist, ey - py * eyeDist, 2.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Length badge
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = 'rgba(255,255,255,0.20)';
    ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(String(s.lenCells), bb.x1 + 8, bb.y1 + 14);
    ctx.restore();

    // (Optional) visualize head lane on hover
    if (highlight) {
      const lane = headLaneRect(s);
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = canExit(s) ? 'rgba(74,222,128,0.55)' : 'rgba(251,113,133,0.55)';
      ctx.fillRect(lane.x1, lane.y1, lane.x2 - lane.x1, lane.y2 - lane.y1);
      ctx.restore();
    }
  }

  function draw() {
    drawBackground();

    const sorted = [...snakes].sort((a, b) => (a.isLeaving ? 1 : 0) - (b.isLeaving ? 1 : 0));

    for (const s of sorted) {
      const can = !s.isLeaving && canExit(s);
      const isHover = hoverId === s.id;

      ctx.save();
      if (!can && !s.isLeaving) ctx.globalAlpha = 0.62;
      drawOneSnake(s, isHover);
      ctx.restore();

      if (isHover && !s.isLeaving) {
        const bb = getAABB(s);
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.lineWidth = 2;
        ctx.strokeStyle = can ? 'rgba(74,222,128,0.85)' : 'rgba(251,113,133,0.85)';
        roundRect(bb.x1, bb.y1, bb.x2 - bb.x1, bb.y2 - bb.y1, 10);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('Click snakes. Green outline = head lane is clear. (Unwinds while leaving)', 16, H - 16);
    ctx.restore();
  }

  // --- Input ---
  function canvasToLocal(evt) {
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (evt.clientX - rect.left) * sx, y: (evt.clientY - rect.top) * sy };
  }

  function findTopSnakeAt(x, y) {
    for (let i = snakes.length - 1; i >= 0; i--) {
      const s = snakes[i];
      if (s.isLeaving) continue;
      if (hitTestSnake(x, y, s)) return s;
    }
    return null;
  }

  canvas.addEventListener('mousemove', (e) => {
    if (animating) return;
    const p = canvasToLocal(e);
    const hit = findTopSnakeAt(p.x, p.y);
    hoverId = hit ? hit.id : null;
    draw();
  });

  canvas.addEventListener('mouseleave', () => {
    hoverId = null;
    draw();
  });

  canvas.addEventListener('click', (e) => {
    if (animating) return;
    const p = canvasToLocal(e);
    const hit = findTopSnakeAt(p.x, p.y);
    if (!hit) return;

    if (!canExit(hit)) {
      showToast(`That snake is <strong>blocked</strong>. Clear its <strong>head lane</strong> to the edge.`);
      return;
    }

    pushHistory();
    moves++;
    movesEl.textContent = String(moves);
    startLeaving(hit);
  });

  // --- Leaving animation (unwind: segments follow head) ---
  function startLeaving(s) {
    const d = DIRS[s.dir];
    s.isLeaving = true;
    ensureSegments(s);

    const speed = 760 + s.thick * 7;
    s.vx = d.dx * speed;
    s.vy = d.dy * speed;

    animating = true;
    showToast(`Snake unwinds and slides <strong>${d.name}</strong> off-screen.`);
    updateHUD();

    let last = performance.now();
    function tick(now) {
      const dt = Math.min(0.032, (now - last) / 1000);
      last = now;

      // Update leaving snakes
      for (const x of snakes) {
        if (!x.isLeaving) continue;
        updateUnwind(x, dt);
      }

      // Remove exited
      snakes = snakes.filter((x) => !isOut(x));

      draw();

      if (snakes.length === 0) {
        animating = false;
        updateHUD();
        showToast(`<strong>Cleared!</strong> Generating a new puzzle…`, 1400);
        setTimeout(() => newPuzzle(true), 750);
        return;
      }

      const anyLeaving = snakes.some((x) => x.isLeaving);
      if (anyLeaving) {
        requestAnimationFrame(tick);
      } else {
        animating = false;
        updateHUD();
        if (!snakes.some((x) => canExit(x))) {
          showToast(`No exits available. Try <strong>Undo</strong> (U) or new puzzle (R).`, 2200);
        }
      }
    }

    requestAnimationFrame(tick);
  }

  function updateUnwind(s, dt) {
    // Move head forward continuously
    const head = s.seg[0];
    head.x += s.vx * dt;
    head.y += s.vy * dt;

    // Each segment follows previous at fixed spacing
    const spacing = CELL;
    for (let i = 1; i < s.seg.length; i++) {
      const prev = s.seg[i - 1];
      const cur = s.seg[i];
      const dx = cur.x - prev.x;
      const dy = cur.y - prev.y;
      const dist = Math.hypot(dx, dy) || 1;
      if (dist > spacing) {
        const ux = dx / dist;
        const uy = dy / dist;
        cur.x = prev.x + ux * spacing;
        cur.y = prev.y + uy * spacing;
      }
    }
  }

  function isOut(s) {
    const bb = getAABB(s);
    return bb.x2 < -EXIT_PADDING || bb.x1 > W + EXIT_PADDING || bb.y2 < -EXIT_PADDING || bb.y1 > H + EXIT_PADDING;
  }

  // --- HUD ---
  function updateHUD() {
    remainingEl.textContent = String(snakes.length);
    movesEl.textContent = String(moves);
    undoBtn.disabled = history.length === 0 || animating;
  }

  // --- Generation ---
  // We still generate on the grid (with bendy tails), but solvability is now guaranteed by a real solver.

  function forwardDot(dx, dy, dirIdx) {
    const d = DIRS[dirIdx];
    return dx * d.dx + dy * d.dy;
  }

  function makeSnakePath(head, dirIdx, lenCells) {
    // cells[0] is head, then each next cell is one step away
    const cells = [{ x: head.x, y: head.y }];

    // First body cell must be behind head
    const d = DIRS[dirIdx];
    let prevDir = { dx: -d.dx, dy: -d.dy };
    let cur = { x: head.x - d.dx, y: head.y - d.dy };
    if (cur.x < 0 || cur.x >= COLS || cur.y < 0 || cur.y >= ROWS) return null;

    cells.push(cur);
    const used = new Set([`${head.x},${head.y}`, `${cur.x},${cur.y}`]);

    for (let i = 2; i < lenCells; i++) {
      const opts = [
        { dx: prevDir.dx, dy: prevDir.dy },
        { dx: -prevDir.dy, dy: prevDir.dx },
        { dx: prevDir.dy, dy: -prevDir.dx }
      ];
      // shuffle
      for (let k = opts.length - 1; k > 0; k--) {
        const j = (Math.random() * (k + 1)) | 0;
        [opts[k], opts[j]] = [opts[j], opts[k]];
      }

      let placed = false;
      for (const step of opts) {
        const nx = cur.x + step.dx;
        const ny = cur.y + step.dy;
        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        const key = `${nx},${ny}`;
        if (used.has(key)) continue;

        // Keep body from going "in front" of the head at generation time.
        // (During leaving it can straighten/unwind, but initial shape should not self-cover the lane.)
        const relx = nx - head.x;
        const rely = ny - head.y;
        if (forwardDot(relx, rely, dirIdx) > 0) continue;

        cur = { x: nx, y: ny };
        cells.push(cur);
        used.add(key);
        prevDir = { dx: step.dx, dy: step.dy };
        placed = true;
        break;
      }
      if (!placed) return null;
    }

    return cells;
  }

  function randomSnakeSpec(i) {
    const dir = randi(0, 3);
    const lenCells = randi(OPTIONS.minLen, OPTIONS.maxLen);
    const thick = clamp(BASE_THICK + randi(-3, 6), 12, 24);
    const seed = (Date.now() + i * 997 + ((Math.random() * 1e6) | 0)) % 10000;
    return { dir, lenCells, thick, seed };
  }

  function placeSnakeNonOverlapping(spec, usedCellsSet) {
    const tries = 180;
    const marginCells = 1;

    for (let t = 0; t < tries; t++) {
      const hx = randi(marginCells, COLS - 1 - marginCells);
      const hy = randi(marginCells, ROWS - 1 - marginCells);

      const head = { x: hx, y: hy };
      const cells = makeSnakePath(head, spec.dir, spec.lenCells);
      if (!cells) continue;

      // Avoid trivial immediate exits (head too close to edge in its heading)
      const d = DIRS[spec.dir];
      const hp = cellCenter(cells[0]);
      const edgeBuffer = 60;
      if (d.dx === 1 && hp.x > W - edgeBuffer) continue;
      if (d.dx === -1 && hp.x < edgeBuffer) continue;
      if (d.dy === 1 && hp.y > H - edgeBuffer) continue;
      if (d.dy === -1 && hp.y < edgeBuffer) continue;

      // Grid-cell overlap check
      let ok = true;
      for (const c of cells) {
        const key = `${c.x},${c.y}`;
        if (usedCellsSet.has(key)) {
          ok = false;
          break;
        }
      }
      if (!ok) continue;

      return {
        id: uuid(),
        dir: spec.dir,
        lenCells: spec.lenCells,
        thick: spec.thick,
        colorSeed: spec.seed,
        cells,
        isLeaving: false,
        seg: null,
        vx: 0,
        vy: 0
      };
    }

    return null;
  }

  function generateCandidate() {
    const count = OPTIONS.count;
    const list = [];
    const usedCells = new Set();

    for (let i = 0; i < count; i++) {
      const spec = randomSnakeSpec(i);
      const placed = placeSnakeNonOverlapping(spec, usedCells);
      if (!placed) return null;
      list.push(placed);
      for (const c of placed.cells) usedCells.add(`${c.x},${c.y}`);
    }

    return list;
  }

  // --- Exact solver (guarantees solvable boards) ---
  // State is a bitmask of remaining snakes. Snakes are static while solving; only removals happen.

  function solveBoard(list) {
    const n = list.length;
    if (n > 20) return null;

    // Precompute AABBs and head-lane rectangles per snake (static geometry)
    const stat = list.map((s) => {
      const bb = getAABB(s);
      const lane = headLaneRect(s);
      return { bb, lane };
    });

    const full = (1 << n) - 1;
    const dead = new Set();
    const choice = new Map();

    // Precompute overlaps for speed: lane(i) blocks by bb(j)
    const laneBlocks = Array.from({ length: n }, () => []);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        if (aabbOverlap(stat[i].lane, stat[j].bb)) laneBlocks[i].push(j);
      }
    }

    // Simple heuristic score: prefer removing snakes that unblock many others
    const unblockScore = new Array(n).fill(0);
    for (let i = 0; i < n; i++) {
      for (let k = 0; k < laneBlocks.length; k++) {
        if (laneBlocks[k].includes(i)) unblockScore[i]++;
      }
    }

    function exits(mask) {
      const out = [];
      for (let i = 0; i < n; i++) {
        if (((mask >> i) & 1) === 0) continue;
        let blocked = false;
        for (const j of laneBlocks[i]) {
          if (((mask >> j) & 1) === 1) {
            blocked = true;
            break;
          }
        }
        if (!blocked) out.push(i);
      }
      // Try more promising first
      out.sort((a, b) => unblockScore[b] - unblockScore[a]);
      return out;
    }

    function dfs(mask) {
      if (mask === 0) return true;
      if (dead.has(mask)) return false;

      const ex = exits(mask);
      if (ex.length === 0) {
        dead.add(mask);
        return false;
      }

      for (const i of ex) {
        const next = mask & ~(1 << i);
        if (dfs(next)) {
          choice.set(mask, i);
          return true;
        }
      }

      dead.add(mask);
      return false;
    }

    const ok = dfs(full);
    if (!ok) return null;

    // Build solution order
    const order = [];
    let m = full;
    while (m) {
      const i = choice.get(m);
      if (i === undefined) break;
      order.push(i);
      m = m & ~(1 << i);
    }

    return order;
  }

  function newPuzzle(afterWin = false) {
    animating = false;
    hoverId = null;
    moves = 0;
    history = [];
    undoBtn.disabled = true;

    let candidate = null;
    let solution = null;

    for (let attempt = 0; attempt < MAX_GEN_ATTEMPTS; attempt++) {
      const c = generateCandidate();
      if (!c) continue;

      // Must have at least one exit
      if (!c.some((s) => canExit(s, c))) continue;

      // Exact solvability check
      const ord = solveBoard(c);
      if (!ord) continue;

      candidate = c;
      solution = ord;
      break;
    }

    if (!candidate) {
      // Fallback: simpler (still solvable)
      let ok = false;
      for (let attempt = 0; attempt < 400 && !ok; attempt++) {
        const c = generateCandidate();
        if (!c) continue;
        const ord = solveBoard(c);
        if (ord) {
          candidate = c;
          solution = ord;
          ok = true;
        }
      }
    }

    snakes = candidate || [];

    if (solution && snakes.length) {
      showToast(
        `Solvable board generated — <strong>${snakes.length}</strong> snakes (len ${OPTIONS.minLen}-${OPTIONS.maxLen}).`,
        afterWin ? 1600 : 1400
      );
    } else {
      showToast(`Board generated — <strong>${snakes.length}</strong> snakes.`, afterWin ? 1600 : 1400);
    }

    updateHUD();
    draw();
  }

  // --- Buttons & keys ---
  newBtn.addEventListener('click', () => newPuzzle(false));
  undoBtn.addEventListener('click', () => popHistory());

  applyBtn.addEventListener('click', () => {
    validateAndClampOptions(true);
    newPuzzle(false);
  });

  [optCount, optMinLen, optMaxLen].forEach((el) => {
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        validateAndClampOptions(true);
        newPuzzle(false);
      }
    });
    el.addEventListener('change', () => {
      validateAndClampOptions(true);
    });
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') newPuzzle(false);
    if (e.key === 'u' || e.key === 'U') if (!animating) popHistory();
  });

  // --- Init ---
  syncOptionsUI();
  validateAndClampOptions(false);
  runSelfTests();
  newPuzzle(false);
  updateHUD();
})();
</script>
</body>
</html>
